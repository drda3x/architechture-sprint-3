# Задача 1.1. Анализ текущего приложения и планирование

## Анализ текущего приложения
#### Язык программирования
Java
#### База данных
PostgreSQL
#### Архитектура
Монолитное, однопоточное приложение, принимающее запросы от пользователей и отправляющее запросы к сенсорам.
#### Взаимодействие
Синхронное
#### Масштабируемость
Масштабируемость возможна путем запуска еще одного инстанса приложения целиком
#### Развертывание
Для развертывания нужна установка приложения + установка и настройка БД.

## Домены и границы контекстов
- Домен. Управление устройствами отопления
    - Контекст. Прием управляющих команд от пользователя
    - Контекст. Установка параметров сенсора. Получение данных от сенсора

## План перехода на микросервисную архитектуру
1. Переработка доменов, определение новых контекстов
1. Определение конкретных микросервисов и их описание
1. Определение механизма взаимодействия микросервисов с пользователем
1. Определение механизма взаимодействия микросервисов между собой
1. Подбор стека
1. Выпуск MVP (реализация компонентов, подготовка документации для API)


# Задача 1.2. Декомпозиция приложения на микросервисы
## Домены и границы контекстов
- Домен. Управление устройствами
    - Поддомен. Управление устройствами
        - Контекст. Добавление/Удаление устройств
        - Контекст. Отправка команд устройствам
- Домен. Дома и группы
    - Контекст. Добавление / удаление пользователей
    - Контекст. Добавление / удаление групп устройств
    - Контекст. Добавление / удаление сценариев


# C4. Диаграммы
    - с4-diagrams/code.puml - диаграмма классов
    - с4-diagrams/component.puml - диаграмма компонентов
    - с4-diagrams/container.puml - диаграмма контейнеров
    - с4-diagrams/context.puml - диаграмма контекста
    - с4-diagrams/er.puml - ER диаграмма

# Документация API
    - device-manager-service/device-manager-api.yaml
    - telemetry-manager-service/telemetry-manager-api.yaml
    - api-gw/api-gw.yaml

# Интеграция с монолитным решением
Для упрощения работы и уменьшения времени, которое нужно потратить на монолитное решение, был выбран вариант 
создания шлюза на уровне api-gw, который будет либо пересылать запрсы к старому монолиту либо отправлять их
через кафку новым микросервисам.

# Инструкция по запуску
## Для локального разветрывания сделан docker-compose.yaml.
`docker compose up`

## Для развертывания в кластеле сделаны helm-чарты на каждый микросервис
1. Запутстить кластер
2. Вызвать `helm install <service_name> <service_folder>`. Папки с чартами располагаются в ./charts


# Защита концепции, ответы на вопросы.
1. Пользовательский запрос будет обработан асинхронно.
Если пользователь прислал команду на изменение состояния устройста, то ApiGw ее примет, зарегистрирует и отправит пользователю ответ о том, что команда принята
Если пользователю нужно знать состояние устройства в данный момент, то у ApiGw будет эта информация и он сможет ее отдать. ApiGw будет кешировать информацию о текущем состоянии для ускорения работы
